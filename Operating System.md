# 운영체제

## 프로세스와 스레드 차이
### 프로세스
#### 메모리 상에서 실행중인 프로그램
#### 프로세스마다 최소 하나의 스레드 보유, 별도의 주소 공간을 독립적으로 할당 (Code, Data, Heap, Stack)


## 스레드
#### 프로세스 안에서 실행되는 흐름 단위
#### Stack만 따로 할당받고, 나머지 영역은 스레드끼리 서로 공유

## 멀치 프로세스로 처리 가능한 것을 멀티 스레드로 처리하는 이유
#### 프로세스를 생성해 자원을 할당하는 시스템 콜이 감소함으로써 자원을 효율적으로 관리 가능
#### 프로세스 간 통신(IPC)보다 스레드 간 통신 비용이 적어 작업들 간 부담이 감소
#### 대신, 멀티 스레드를 사용할 때는 공유 자원으로 인한 문제 해결을 위해 '동기화'에 신경써야 함

## 프로세스의 주소 공간
#### 프로그램이 CPU에 의해 실행됨 -> 프로세스가 생성되고 메모리에 프로세스 주소 공간이 할당됨

#### 프로세스 주소 공간은 코드, 데이터, 스택으로 구성
- 코드 : 소스 코드 저장
- 데이터 : 전역 변수 저장
- 스택 : 함수, 지역 변수 저장

## 인터럽트 (Interrupt)
#### 프로그램 실행 도중 예기치 않은 상황이 발생할 경우, 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황을 우선 처리한 후 실행 중이던 작업으로 복귀하는 것
#### 현재 수행 중인 일보다 더 중요한 일(ex. 입출력, 우선 순위 연산 등)이 발생하면 그 일을 먼저 처리하고 나서 하던 일을 계속해야 함

- 외부 인터럽트
  - 입출력 장치, 타이밍 장치, 전원 등 외부적인 요인으로 발생
  - 전원 이상, 기계 고장, 외부 신호, 입출력
- 내부 인터럽트
  - Trap이라 부르며, 잘못된 명령이나 데이터를 사용할 때 발생
  - 0으로 나누기, 오버플로우, 명령어를 잘못 사용(Exception)
  - 소프트웨어 인터럽트
    - 프로그램 처리 중 명령의 요청에 의해 발생한 것 (SVC 인터럽트)
    - 사용자가 프로그램을 실행시킬 때 발생
    - 소프트웨어 이용 중 다른 프로세스를 실행시키면 시분할 처리를 위해 자원 할당 동작이 수행

## 인터럽트 발생 처리 과정
![image](https://user-images.githubusercontent.com/51224070/108592223-28bf5c00-73b0-11eb-92f5-c3bbcad5bab6.png)

## Process Management
#### 프로세스가 여러개일 때, CPU 스케줄링을 통해 관리하는 것
#### CPU는 각 프로세스가 누군지 알아야 관리가 가능
#### 프로세스들의 특징을 갖고 있는 것이 바로 Process Metadata

#### Process Metadata
- Process ID
- Process Stage
- Process Priority
- CPU Registers
- Owner
- CPU Usage
- Memory Usage

#### 프로세스가 생성되면 메타데이터는 PCB에 저장됨

## PCB (Process Control Block)
#### 메타데이터를 저장하는 곳, 한 PCB 안에는 한 프로세스의 정보가 담김
  
#### PCB가 필요한 이유
#### CPU는 프로세스의 상태에 따라 교체 작업이 이루어짐 -> 앞으로 다시 수행할 대기 중인 프로세스에 관한 저장 값을 PCB에 저장
   
#### PCB 관리
#### Linked List 방식으로 관리 -> 삽입, 삭제 용이
#### 프로세스 생성시 해당 PCB 생성, 프로세스 완료시 제거
#### 수행 중인 프로세스를 변경할 때, CPU의 레지스터 정보가 변경되는 것 -> Context Switching

## Context Switching
#### CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에서 읽어 레지스터에 적재하는 과정
#### 인터럽트가 발생, 실행 중인 CPU 사용 허가시간을 모두 소모, 입출력을 위해 대기해야 하는 경우 Context Switching이 발생
#### 프로세스가 Ready -> Running, Running -> Ready, Running -> Waiting 처럼 상태 변경 시 발생

## IPC (Inter Process Communication)
    프로세스는 독립적으로 실행 => 다른 프로세스에게 영향을 받지 않는다
    독립적 구조를 가진 프로세스 간의 통신을 해야 하는 상황 => IPC 통신

## IPC 종류
    익명 PIPE
    Named PIPE
    Message Queue
    공유 메모리
    메모리 앱
    소켓

## 스케줄링
    CPU를 잘 사용하기 위해 프로세스를 잘 배정하기

## 선점 (Preemptive) VS 비선점 (Nonpreemptive)
    선점 : OS가 CPU의 사용권을 선점할 수 있는 경우, 강제 회수하는 경우
    비선점 : 프로세스 종료 or I/O 등의 이벤트가 있을 때까지 실행 보장 (처리시간 예측 불가능)

![image](https://user-images.githubusercontent.com/51224070/111459610-40df8c80-875e-11eb-921b-882076b54ec0.png)

    선점 스케줄링 : I/O or Event Wait
    비선점 스케줄링 : Interrupt, Scheduler Dispatch

## 프로세스 상태 전이
    승인 (Admitted) : 프로세스 생성이 가능하여 승인됨
    스케줄러 디스패치 (Scheduler Dispatch) : 준비 상태에 있는 프로세스 중 하나를 선택하여 실행시키는 것
    인터럽트 (Interrupt) : 예외, 입출력, 이벤트 등이 발생하여 현재 실행중인 프로세스를 준비 상태로 바꾸고, 해당 작업을 먼저 처리하는 것
    입출력 또는 이벤트 대기 (I/O or Event Wait) : 실행중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력/이벤트가 모두 끝날 때 까지 대기 상태로 만드는 것
    입출력 또는 이벤트 완료 (I/O or Event Completion) : 입출력/이벤트가 끝난 프로세스를 준비 상태로 전환하여 스케줄러에 의해 선택될 수 있도록 만드는 것

## CPU 스케줄링의 종류
#### 비선점 스케줄링
    1. FCFS (First Come First Service)
        - 큐에 도착한 순서대로 CPU 할당
        - 실행 시간이 짧은 것이 뒤로 가면 평균 대기 시간이 길어짐

    2. SJF (Shortest Job First)
        - 수행시간이 가장 짧은 작업을 먼저 수행
        - FCFS보다 평균 대기 시간 감소, 짧은 작업에 유리

#### 선점 스케줄링
    1. Priority Scheduling
        - 정적/동적으로 우선순위를 부여하여 우선순위가 높은 순서대로 처리
        - 우선 순위가 낮은 프로세스는 무한정 기다리는 Starvation(기아)이 생길 수 있음
        - Aging 방법으로 Starvation 문제 해결 가능

    2. Round Robin
        - FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 시간의 Time Quantum 만큼 CPU를 할당 받음
            - Time Quantum or Time Slice : 실행의 최소 단위 시간
        - 할당 시간 (Time Slice)가 크면 FCFS와 같게 되고, 작으면 문맥 교환 (Context Switching)이 잦아져서 오버헤드 증가

    3. Multilevel-Queue (다단계 큐)
        - 작업들을 여러 종류의 그룹으로 나누어 여러 개의 큐를 이용하는 방법
        - 우선순위가 낮은 큐들이 실행 못하는 것을 방지하고자 각 큐마다 다른 Time Slice를 설정하는 방식
        - 우선순위가 높은 큐는 작은 Time Slice 할당. 우선순쉬가 낮은 큐는 큰 Time Slice 할당

    4. Multilevel-Feedback-Queue (다단계 피드백 큐)
        - 다단계 큐에서 자신의 Time Slice를 다 채운 프로세스는 밑으로 내려가고, 채우지 못한 프로세스는 원래 큐 그대로
        - 짧은 작업에 유리, 입출력 위주(Interrupt가 잦은) 작업에 우선권을 줌
        - 처리 시간이 짧은 프로세스를 먼저 처리하기 때문에 Turnaround 평균 시간을 줄여줌

## CPU 스케줄링 척도
    Response Time : 작업이 처음 실행되기까지 걸린 시간
    Turnaround Time : 실행 시간과 대기 시간을 모두 합한 시간, 작업 완료까지 걸린 시간
