# 운영체제

## 프로세스와 스레드 차이
### 프로세스
#### 메모리 상에서 실행중인 프로그램
#### 프로세스마다 최소 하나의 스레드 보유, 별도의 주소 공간을 독립적으로 할당 (Code, Data, Heap, Stack)


## 스레드
#### 프로세스 안에서 실행되는 흐름 단위
#### Stack만 따로 할당받고, 나머지 영역은 스레드끼리 서로 공유

## 멀치 프로세스로 처리 가능한 것을 멀티 스레드로 처리하는 이유
#### 프로세스를 생성해 자원을 할당하는 시스템 콜이 감소함으로써 자원을 효율적으로 관리 가능
#### 프로세스 간 통신(IPC)보다 스레드 간 통신 비용이 적어 작업들 간 부담이 감소
#### 대신, 멀티 스레드를 사용할 때는 공유 자원으로 인한 문제 해결을 위해 '동기화'에 신경써야 함

## 프로세스의 주소 공간
#### 프로그램이 CPU에 의해 실행됨 -> 프로세스가 생성되고 메모리에 프로세스 주소 공간이 할당됨

#### 프로세스 주소 공간은 코드, 데이터, 스택으로 구성
- 코드 : 소스 코드 저장
- 데이터 : 전역 변수 저장
- 스택 : 함수, 지역 변수 저장

## 인터럽트 (Interrupt)
#### 프로그램 실행 도중 예기치 않은 상황이 발생할 경우, 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황을 우선 처리한 후 실행 중이던 작업으로 복귀하는 것
#### 현재 수행 중인 일보다 더 중요한 일(ex. 입출력, 우선 순위 연산 등)이 발생하면 그 일을 먼저 처리하고 나서 하던 일을 계속해야 함

- 외부 인터럽트
  - 입출력 장치, 타이밍 장치, 전원 등 외부적인 요인으로 발생
  - 전원 이상, 기계 고장, 외부 신호, 입출력
- 내부 인터럽트
  - Trap이라 부르며, 잘못된 명령이나 데이터를 사용할 때 발생
  - 0으로 나누기, 오버플로우, 명령어를 잘못 사용(Exception)
  - 소프트웨어 인터럽트
    - 프로그램 처리 중 명령의 요청에 의해 발생한 것 (SVC 인터럽트)
    - 사용자가 프로그램을 실행시킬 때 발생
    - 소프트웨어 이용 중 다른 프로세스를 실행시키면 시분할 처리를 위해 자원 할당 동작이 수행

## 인터럽트 발생 처리 과정
![image](https://user-images.githubusercontent.com/51224070/108592223-28bf5c00-73b0-11eb-92f5-c3bbcad5bab6.png)

## Process Management
#### 프로세스가 여러개일 때, CPU 스케줄링을 통해 관리하는 것
#### CPU는 각 프로세스가 누군지 알아야 관리가 가능
#### 프로세스들의 특징을 갖고 있는 것이 바로 Process Metadata

#### Process Metadata
- Process ID
- Process Stage
- Process Priority
- CPU Registers
- Owner
- CPU Usage
- Memory Usage

#### 프로세스가 생성되면 메타데이터는 PCB에 저장됨

## PCB (Process Control Block)
#### 메타데이터를 저장하는 곳, 한 PCB 안에는 한 프로세스의 정보가 담김
  
#### PCB가 필요한 이유
#### CPU는 프로세스의 상태에 따라 교체 작업이 이루어짐 -> 앞으로 다시 수행할 대기 중인 프로세스에 관한 저장 값을 PCB에 저장
   
#### PCB 관리
#### Linked List 방식으로 관리 -> 삽입, 삭제 용이
#### 프로세스 생성시 해당 PCB 생성, 프로세스 완료시 제거
#### 수행 중인 프로세스를 변경할 때, CPU의 레지스터 정보가 변경되는 것 -> Context Switching

## Context Switching
#### CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에서 읽어 레지스터에 적재하는 과정
#### 인터럽트가 발생, 실행 중인 CPU 사용 허가시간을 모두 소모, 입출력을 위해 대기해야 하는 경우 Context Switching이 발생
#### 프로세스가 Ready -> Running, Running -> Ready, Running -> Waiting 처럼 상태 변경 시 발생

## IPC (Inter Process Communication)
    프로세스는 독립적으로 실행 => 다른 프로세스에게 영향을 받지 않는다
    독립적 구조를 가진 프로세스 간의 통신을 해야 하는 상황 => IPC 통신

## IPC 종류
    익명 PIPE
    Named PIPE
    Message Queue
    공유 메모리
    메모리 앱
    소켓

## 스케줄링
    CPU를 잘 사용하기 위해 프로세스를 잘 배정하기

## 선점 (Preemptive) VS 비선점 (Nonpreemptive)
    선점 : OS가 CPU의 사용권을 선점할 수 있는 경우, 강제 회수하는 경우
    비선점 : 프로세스 종료 or I/O 등의 이벤트가 있을 때까지 실행 보장 (처리시간 예측 불가능)

![image](https://user-images.githubusercontent.com/51224070/111459610-40df8c80-875e-11eb-921b-882076b54ec0.png)

    선점 스케줄링 : I/O or Event Wait
    비선점 스케줄링 : Interrupt, Scheduler Dispatch

## 프로세스 상태 전이
    승인 (Admitted) : 프로세스 생성이 가능하여 승인됨
    스케줄러 디스패치 (Scheduler Dispatch) : 준비 상태에 있는 프로세스 중 하나를 선택하여 실행시키는 것
    인터럽트 (Interrupt) : 예외, 입출력, 이벤트 등이 발생하여 현재 실행중인 프로세스를 준비 상태로 바꾸고, 해당 작업을 먼저 처리하는 것
    입출력 또는 이벤트 대기 (I/O or Event Wait) : 실행중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력/이벤트가 모두 끝날 때 까지 대기 상태로 만드는 것
    입출력 또는 이벤트 완료 (I/O or Event Completion) : 입출력/이벤트가 끝난 프로세스를 준비 상태로 전환하여 스케줄러에 의해 선택될 수 있도록 만드는 것

## CPU 스케줄링의 종류
#### 비선점 스케줄링
    1. FCFS (First Come First Service)
        - 큐에 도착한 순서대로 CPU 할당
        - 실행 시간이 짧은 것이 뒤로 가면 평균 대기 시간이 길어짐

    2. SJF (Shortest Job First)
        - 수행시간이 가장 짧은 작업을 먼저 수행
        - FCFS보다 평균 대기 시간 감소, 짧은 작업에 유리

#### 선점 스케줄링
    1. Priority Scheduling
        - 정적/동적으로 우선순위를 부여하여 우선순위가 높은 순서대로 처리
        - 우선 순위가 낮은 프로세스는 무한정 기다리는 Starvation(기아)이 생길 수 있음
        - Aging 방법으로 Starvation 문제 해결 가능

    2. Round Robin
        - FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 시간의 Time Quantum 만큼 CPU를 할당 받음
            - Time Quantum or Time Slice : 실행의 최소 단위 시간
        - 할당 시간 (Time Slice)가 크면 FCFS와 같게 되고, 작으면 문맥 교환 (Context Switching)이 잦아져서 오버헤드 증가

    3. Multilevel-Queue (다단계 큐)
        - 작업들을 여러 종류의 그룹으로 나누어 여러 개의 큐를 이용하는 방법
        - 우선순위가 낮은 큐들이 실행 못하는 것을 방지하고자 각 큐마다 다른 Time Slice를 설정하는 방식
        - 우선순위가 높은 큐는 작은 Time Slice 할당. 우선순쉬가 낮은 큐는 큰 Time Slice 할당

    4. Multilevel-Feedback-Queue (다단계 피드백 큐)
        - 다단계 큐에서 자신의 Time Slice를 다 채운 프로세스는 밑으로 내려가고, 채우지 못한 프로세스는 원래 큐 그대로
        - 짧은 작업에 유리, 입출력 위주(Interrupt가 잦은) 작업에 우선권을 줌
        - 처리 시간이 짧은 프로세스를 먼저 처리하기 때문에 Turnaround 평균 시간을 줄여줌

## CPU 스케줄링 척도
    Response Time : 작업이 처음 실행되기까지 걸린 시간
    Turnaround Time : 실행 시간과 대기 시간을 모두 합한 시간, 작업 완료까지 걸린 시간

## 데드락 (DeadLock)
    프로세스가 자원을 얻지 못해서 다음 처리를 하지 못하는 상태
    ‘교착 상태’라고도 부름
    한정된 자원을 여려 곳에서 사용하려고 할 때 발생

## 데드락 발생 조건
    4가지 모두 성립해야 데드락 발생 (하나라도 성립하지 않으면 데드락 문제 해결 가능)
    
    1. 상호 배제 (Mutual Exclusion)
    - 자원은 한번에 한 프로세스만 사용할 수 있음

    2. 점유 대기 (Hold and Wait)
    - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 있는 자원을 점유하기 위해 대기하는 프로세스가 존재해야 함

    3. 비선점 (Non Preemptive)
    - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음

    4. 순환 대기 (Circular Wait)
    - 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함

## 데드락 처리
#### 교착 상태 예방 & 회피
    1. 예방 (Prevention)
    교착 상태 발생 조건 중 하나를 제거하면서 해결 (자원 낭비 엄청 심함)
    
    - 상호배제 부정 : 여러 프로세스가 공유 자원 사용
    - 점유대기 부정 : 프로세스 실행 전 모든 자원을 할당
    - 비선점 부정 : 자원을 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납
    - 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구

    2. 회피 (Avoidance)
    교착 상태 발생 시 피해가는 방법

    은행원 알고리즘 (Banker’s Algorithm)
    - 은행이 최소한 한 명에게 대출해줄 수 있는 금액을 항상 보유하고 있어야 한다는 개념에서 나옴
    - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착상태 회피
    - 안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 대기

#### 교착 상태 탐지 & 회복 : 교착 상태가 되도록 허용한 다음 회복시키는 방법
    1. 탐지 (Detection)
    자원 할당 그래프를 통해 교착 상태를 탐지
    자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생

    2. 회복 (Recovery)
    교착 상태를 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복하는 방법
